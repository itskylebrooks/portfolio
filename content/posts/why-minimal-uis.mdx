export const meta = {
  title: 'Why I Build Minimal UIs',
  date: '2025-10-6',
  summary: 'Notes on clarity, speed, and the art of removing unnecessary weight.',
}

### Why minimal

I like software that doesn’t ask for attention. When the interface disappears, intent remains. Minimal isn’t an aesthetic veneer; it’s a method of subtraction. Remove what doesn’t move the user forward, and the product gets faster, clearer, and calmer.

### The method in practice

Fewer decisions per screen, fewer moving parts, fewer milliseconds. Motion only when it explains causality (“this came from here”). Words carry weight—labels that read like answers, errors that teach, empty states that invite a first step.

```ts
const keep = features.filter(f => value(f) > weight(f))
// value = frequency × impact × learning
// weight = complexity × attention × failure surface
```

Defaults are silent mentors: if a user changes one once and never again, that’s a win. Speed is respect—the first 100–200 ms decide whether an app feels alive.

### The subtraction pass

Before shipping, I do one quiet sweep: delete a field we can infer, merge two screens, demote an option behind “Advanced,” remove a setting a good default makes irrelevant. If behavior improves—or doesn’t change—the deletion stays.

### Why it matters

Software shapes habits. Heavy UIs create heavy workflows; light, honest interfaces build momentum. The tool is the stagehand; the user is the protagonist. Ship the core. Watch. Subtract again.

I build minimal UIs so the user can be the protagonist. The interface is the stagehand—present, competent, nearly invisible. The tool gets out of the way so the person can get on with their life.

Design is subtraction. Ship the core. Iterate. Subtract again.

The craft is not in how much I add, but in how little I need.